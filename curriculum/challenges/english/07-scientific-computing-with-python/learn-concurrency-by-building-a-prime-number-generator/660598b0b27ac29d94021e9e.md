---
id: 660598b0b27ac29d94021e9e
title: Step 23
challengeType: 20
dashedName: step-23
---

# --description--

Once all the tasks are complete, the event loop is closed using `loop.close()`. This is good practice to clean up resources and properly terminate the event loop.

Close the event loop using `loop.close()`.

After closing the loop, uncomment the second last line of code.

In the output, you can see that the largest range would take the longest to complete, but it won't hinder the processing of other ranges.

With this, you have successfully implemented concurrency in Python using asyncio.

# --hints--

Uncomment `primes1, primes2, primes3 = loop.run_until_complete(main())`.

```js
({
    test: () => assert(runPython(`_Node(_code).find_ifs()[0].find_body()[1].is_equivalent("primes1, primes2, primes3 = loop.run_until_complete(main())")`))
})
```

Add `loop.close` to the end of the code.

```js
({
    test: () => assert(runPython(`_Node(_code).find_ifs()[0].find_body()[2].is_equivalent("loop.close()")`))
})
```

# --seed--

## --seed-contents--


```py
import asyncio


async def find_primes(start, end):

    print(f"Finding prime numbers between {start} and {end}.")
    primes = []
    for val in range(start, end + 1):
        if val > 1:
            for n in range(2, val):
                if (val % n) == 0:
                    break
            else:
                primes.append(val)
                await asyncio.sleep(0.000001)

    print(f"DONE finding prime numbers between {start} and {end}. Total: {len(primes)}")
    return primes


async def main():
    primes1 = loop.create_task(find_primes(100, 10000))
    primes2 = loop.create_task(find_primes(10, 100))
    primes3 = loop.create_task(find_primes(1, 10))
    await asyncio.wait([primes1, primes2, primes3])
    return primes1, primes2, primes3


--fcc-editable-region--
if __name__ == "__main__":
    loop = asyncio.get_event_loop()
    # primes1, primes2, primes3 = loop.run_until_complete(main())

--fcc-editable-region--
```

# --solutions--

```py

import asyncio

async def find_primes(start, end):
    
    print(f"Finding prime numbers between {start} and {end}.")
    primes = []
    for val in range(start, end + 1):
        if val > 1:
            for n in range(2, val):
                if (val % n) == 0:
                    break
            else:
                primes.append(val)
                await asyncio.sleep(0.000001)

    print(f"DONE finding prime numbers between {start} and {end}. Total: {len(primes)}")
    return primes


async def main():
    primes1 = loop.create_task(find_primes(100, 10000))
    primes2 = loop.create_task(find_primes(10, 100))
    primes3 = loop.create_task(find_primes(1, 10))
    await asyncio.wait([primes1, primes2, primes3])
    return primes1, primes2, primes3


if __name__ == "__main__":
    loop = asyncio.get_event_loop()
    primes1, primes2, primes3 = loop.run_until_complete(main())
    loop.close()
```
